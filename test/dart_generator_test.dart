import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_native_bridge/src/generator/generator.dart';

void main() {
  group('DartGenerator', () {
    late DartGenerator generator;

    setUp(() {
      generator = DartGenerator();
    });

    test('generates class with static methods', () {
      final classes = [
        NativeClass('DeviceService', [
          NativeMethod('getModel', 'String', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('class DeviceService'));
      expect(code, contains('static Future<String?>'));
      expect(code, contains('getModel()'));
      expect(code, contains("'DeviceService.getModel'"));
    });

    test('generates methods with parameters', () {
      final classes = [
        NativeClass('Service', [
          NativeMethod('greet', 'String', [
            NativeParam('name', 'String'),
          ]),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('greet(String name)'));
      expect(code, contains("'Service.greet', name"));
    });

    test('generates methods with multiple parameters as map', () {
      final classes = [
        NativeClass('Calculator', [
          NativeMethod('add', 'Int', [
            NativeParam('a', 'Int'),
            NativeParam('b', 'Int'),
          ]),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('add(int a, int b)'));
      expect(code, contains("{'a': a, 'b': b}"));
    });

    test('maps Kotlin types to Dart types', () {
      final classes = [
        NativeClass('TypeTest', [
          NativeMethod('getString', 'String', []),
          NativeMethod('getInt', 'Int', []),
          NativeMethod('getLong', 'Long', []),
          NativeMethod('getDouble', 'Double', []),
          NativeMethod('getFloat', 'Float', []),
          NativeMethod('getBool', 'Boolean', []),
          NativeMethod('getUnit', 'Unit', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('Future<String?>'));
      expect(code, contains('Future<int?> getInt'));
      expect(code, contains('Future<int?> getLong'));
      expect(code, contains('Future<double?> getDouble'));
      expect(code, contains('Future<double?> getFloat'));
      expect(code, contains('Future<bool?> getBool'));
      expect(code, contains('Future<void?> getUnit'));
    });

    test('maps Swift types to Dart types', () {
      final classes = [
        NativeClass('SwiftTypes', [
          NativeMethod('getString', 'String', []),
          NativeMethod('getInt', 'Int', []),
          NativeMethod('getDouble', 'Double', []),
          NativeMethod('getBool', 'Bool', []),
          NativeMethod('getVoid', 'Void', []),
        ], platform: 'ios'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('Future<String?>'));
      expect(code, contains('Future<int?> getInt'));
      expect(code, contains('Future<double?> getDouble'));
      expect(code, contains('Future<bool?> getBool'));
      expect(code, contains('Future<void?> getVoid'));
    });

    test('merges classes with same name from different platforms', () {
      final classes = [
        NativeClass('DeviceService', [
          NativeMethod('getModel', 'String', []),
          NativeMethod('getAndroidVersion', 'Int', []),
        ], platform: 'android'),
        NativeClass('DeviceService', [
          NativeMethod('getModel', 'String', []),
          NativeMethod('getIOSVersion', 'String', []),
        ], platform: 'ios'),
      ];

      final code = generator.generate(classes);

      // Should have one class with methods from both platforms
      final classMatches = RegExp(r'class DeviceService').allMatches(code);
      expect(classMatches.length, 1);

      // Should have all methods
      expect(code, contains('getModel'));
      expect(code, contains('getAndroidVersion'));
      expect(code, contains('getIOSVersion'));
    });

    test('generates header comment', () {
      final classes = [
        NativeClass('Test', [
          NativeMethod('method', 'String', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('GENERATED CODE - DO NOT MODIFY BY HAND'));
      expect(code, contains('Generated by flutter_native_bridge'));
    });

    test('imports flutter/services.dart', () {
      final classes = [
        NativeClass('Test', [
          NativeMethod('method', 'String', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains("import 'package:flutter/services.dart'"));
    });

    test('creates MethodChannel constant', () {
      final classes = [
        NativeClass('Test', [
          NativeMethod('method', 'String', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains("const _channel = MethodChannel('flutter_native_bridge')"));
    });

    test('generates private constructor', () {
      final classes = [
        NativeClass('Service', [
          NativeMethod('method', 'String', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('Service._()'));
    });

    test('generates doc comments', () {
      final classes = [
        NativeClass('Service', [
          NativeMethod('doAction', 'String', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('/// Generated bridge for Service'));
      expect(code, contains('/// Calls native Service.doAction'));
    });

    test('handles empty class list', () {
      final code = generator.generate([]);

      expect(code, contains('GENERATED CODE'));
      expect(code, contains("import 'package:flutter/services.dart'"));
    });

    test('handles collection types', () {
      final classes = [
        NativeClass('Collections', [
          NativeMethod('getList', 'List<String>', []),
          NativeMethod('getMap', 'Map<String, Any>', []),
        ], platform: 'android'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('Future<List<String>?>'));
      expect(code, contains('Future<Map<String, dynamic>?>'));
    });

    test('handles Swift collection types', () {
      final classes = [
        NativeClass('SwiftCollections', [
          NativeMethod('getArray', '[String]', []),
          NativeMethod('getDict', '[String: Any]', []),
        ], platform: 'ios'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('Future<List<String>?>'));
      expect(code, contains('Future<Map<String, dynamic>?>'));
    });

    test('generates multiple classes', () {
      final classes = [
        NativeClass('Service1', [
          NativeMethod('method1', 'String', []),
        ], platform: 'android'),
        NativeClass('Service2', [
          NativeMethod('method2', 'Int', []),
        ], platform: 'android'),
        NativeClass('Service3', [
          NativeMethod('method3', 'Bool', []),
        ], platform: 'ios'),
      ];

      final code = generator.generate(classes);

      expect(code, contains('class Service1'));
      expect(code, contains('class Service2'));
      expect(code, contains('class Service3'));
    });
  });
}
